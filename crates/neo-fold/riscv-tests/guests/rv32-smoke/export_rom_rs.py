#!/usr/bin/env python3

from __future__ import annotations

import hashlib
import struct
import subprocess
import sys
from pathlib import Path


def _read_cstr(buf: bytes, off: int) -> str:
    end = buf.find(b"\x00", off)
    if end < 0:
        raise ValueError("unterminated string in shstrtab")
    return buf[off:end].decode("utf-8", errors="strict")


def _extract_elf32_section(data: bytes, section_name: str) -> tuple[int, bytes]:
    if data[:4] != b"\x7fELF":
        raise ValueError("not an ELF file")

    ei_class = data[4]
    ei_data = data[5]
    if ei_class != 1:
        raise ValueError(f"expected ELFCLASS32 (1), got {ei_class}")
    if ei_data != 1:
        raise ValueError(f"expected little-endian ELF (1), got {ei_data}")

    e_shoff = struct.unpack_from("<I", data, 0x20)[0]
    e_shentsize = struct.unpack_from("<H", data, 0x2E)[0]
    e_shnum = struct.unpack_from("<H", data, 0x30)[0]
    e_shstrndx = struct.unpack_from("<H", data, 0x32)[0]
    if e_shoff == 0 or e_shnum == 0:
        raise ValueError("ELF has no section header table")
    if e_shentsize == 0:
        raise ValueError("ELF e_shentsize is 0")
    if e_shstrndx >= e_shnum:
        raise ValueError(f"invalid e_shstrndx={e_shstrndx} for e_shnum={e_shnum}")

    def read_shdr(i: int) -> tuple[int, int, int, int, int]:
        off = e_shoff + i * e_shentsize
        sh_name = struct.unpack_from("<I", data, off + 0x00)[0]
        sh_addr = struct.unpack_from("<I", data, off + 0x0C)[0]
        sh_offset = struct.unpack_from("<I", data, off + 0x10)[0]
        sh_size = struct.unpack_from("<I", data, off + 0x14)[0]
        sh_addralign = struct.unpack_from("<I", data, off + 0x20)[0]
        return sh_name, sh_addr, sh_offset, sh_size, sh_addralign

    shstr_name, shstr_addr, shstr_off, shstr_size, _shstr_align = read_shdr(e_shstrndx)
    _ = shstr_name, shstr_addr  # unused, but kept for clarity
    shstrtab = data[shstr_off : shstr_off + shstr_size]

    for i in range(e_shnum):
        sh_name, sh_addr, sh_offset, sh_size, sh_addralign = read_shdr(i)
        if sh_name >= len(shstrtab):
            continue
        name = _read_cstr(shstrtab, sh_name)
        if name != section_name:
            continue
        if sh_offset + sh_size > len(data):
            raise ValueError(f"section {section_name} is out of bounds")
        if sh_addralign and (sh_addr % sh_addralign) != 0:
            raise ValueError(f"section {section_name} addr alignment mismatch")
        return sh_addr, data[sh_offset : sh_offset + sh_size]

    raise ValueError(f"missing section {section_name}")


def _format_u8_array(name: str, base: int, content: bytes, sha256_hex: str) -> str:
    lines = []
    lines.append("// @generated by crates/neo-fold/riscv-tests/guests/rv32-smoke/export_rom_rs.py")
    lines.append(f"// sha256={sha256_hex}")
    lines.append("")
    lines.append(f"pub const {name}_BASE: u64 = {base}u64;")
    lines.append(f"pub const {name}: [u8; {len(content)}] = [")
    for i in range(0, len(content), 16):
        chunk = content[i : i + 16]
        hexes = ", ".join(f"0x{b:02x}" for b in chunk)
        lines.append(f"    {hexes},")
    lines.append("];")
    lines.append("")
    return "\n".join(lines)


def _find_repo_root(start: Path) -> Path:
    for cand in [start, *start.parents]:
        if (cand / "Cargo.toml").is_file() and (cand / "crates").is_dir():
            return cand
    raise FileNotFoundError(f"failed to find repo root from {start}")


def main() -> int:
    guest_dir = Path(__file__).resolve().parent
    repo_root = _find_repo_root(guest_dir)
    out_rs = repo_root / "crates/neo-fold/riscv-tests/binaries/rv32_smoke_rom.rs"

    subprocess.run(["cargo", "build", "--release"], cwd=guest_dir, check=True)

    elf = guest_dir / "target/riscv32im-unknown-none-elf/release/rv32_smoke"
    if not elf.exists():
        raise FileNotFoundError(f"missing expected ELF: {elf}")

    data = elf.read_bytes()
    base, text = _extract_elf32_section(data, ".neo_start")
    if base != 0:
        raise ValueError(f"expected .neo_start base=0, got {base:#x}")
    if len(text) == 0:
        raise ValueError(".neo_start is empty")
    if len(text) % 4 != 0:
        raise ValueError(f".neo_start length must be multiple of 4, got {len(text)}")

    sha256_hex = hashlib.sha256(text).hexdigest()
    out_rs.parent.mkdir(parents=True, exist_ok=True)
    out_rs.write_text(_format_u8_array("RV32_SMOKE_ROM", base, text, sha256_hex), encoding="utf-8")

    rel = out_rs.relative_to(repo_root)
    print(f"Wrote {rel} (len={len(text)} sha256={sha256_hex})")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
